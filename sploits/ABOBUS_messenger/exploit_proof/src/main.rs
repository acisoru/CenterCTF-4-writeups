use core::iter;
extern crate alloc;

use merlin::Transcript;
use base64::{engine::general_purpose::STANDARD, Engine as _};
use bulletproofs::{inner_product_proof::{inner_product, InnerProductProof}, util, BulletproofGens, ProofError};
use curve25519_dalek::{ristretto::CompressedRistretto, RistrettoPoint, scalar::Scalar, traits::VartimeMultiscalarMul,digest::Update};
use sha2::{Sha512,Digest};
use alloc::borrow::Borrow;
use bulletproofs::transcript::TranscriptProtocol;

#[derive(Clone, Debug)]
pub struct InnerProductProofForge {
    pub(crate) L_vec: Vec<CompressedRistretto>,
    pub(crate) R_vec: Vec<CompressedRistretto>,
    pub(crate) a: Scalar,
    pub(crate) b: Scalar,
}

fn verification_scalars(
    L_vec: &Vec<CompressedRistretto>,
    R_vec: &Vec<CompressedRistretto>,
    n: usize,
    transcript: &mut Transcript,
) -> Result<(Vec<Scalar>, Vec<Scalar>, Vec<Scalar>), ProofError> {
    let lg_n = L_vec.len();
    if lg_n >= 32 {
        // 4 billion multiplications should be enough for anyone
        // and this check prevents overflow in 1<<lg_n below.
        return Err(ProofError::VerificationError);
    }
    if n != (1 << lg_n) {
        return Err(ProofError::VerificationError);
    }

    transcript.innerproduct_domain_sep(n as u64);

    // 1. Recompute x_k,...,x_1 based on the proof transcript

    let mut challenges = Vec::with_capacity(lg_n);
    for (L, R) in L_vec.iter().zip(R_vec.iter()) {
        transcript.validate_and_append_point(b"L", L)?;
        transcript.validate_and_append_point(b"R", R)?;
        challenges.push(transcript.challenge_scalar(b"u"));
    }

    // 2. Compute 1/(u_k...u_1) and 1/u_k, ..., 1/u_1

    let mut challenges_inv = challenges.clone();
    let allinv = Scalar::batch_invert(&mut challenges_inv);

    // 3. Compute u_i^2 and (1/u_i)^2

    for i in 0..lg_n {
        // XXX missing square fn upstream
        challenges[i] = challenges[i] * challenges[i];
        challenges_inv[i] = challenges_inv[i] * challenges_inv[i];
    }
    let challenges_sq = challenges;
    let challenges_inv_sq = challenges_inv;

    // 4. Compute s values inductively.

    let mut s = Vec::with_capacity(n);
    s.push(allinv);
    for i in 1..n {
        let lg_i = (32 - 1 - (i as u32).leading_zeros()) as usize;
        let k = 1 << lg_i;
        // The challenges are stored in "creation order" as [u_k,...,u_1],
        // so u_{lg(i)+1} = is indexed by (lg_n-1) - lg_i
        let u_lg_i_sq = challenges_sq[(lg_n - 1) - lg_i];
        s.push(s[i - k] * u_lg_i_sq);
    }

    Ok((challenges_sq, challenges_inv_sq, s))
}

fn format_proof(P:&RistrettoPoint, proof: &InnerProductProofForge ) -> Vec<u8>{
    let mut buf = Vec::with_capacity((proof.L_vec.len() * 2 + 2) * 32);
    buf.extend_from_slice(&P.compress().to_bytes());
    for (l, r) in proof.L_vec.iter().zip(proof.R_vec.iter()) {
        buf.extend_from_slice(l.as_bytes());
        buf.extend_from_slice(r.as_bytes());
    }
    buf.extend_from_slice(proof.a.as_bytes());
    buf.extend_from_slice(proof.b.as_bytes());
    buf
}
pub fn forge_proof(username: &String)-> Result<String,ProofError>{
    // our_P =
    // + a*s_0*G_0 + a*s_1*G_1 +... + // we control only a
    // - (Ls[0]*u_sq[0] +Ls[1]*u_sq[1] + ...)
    // - (Rs[0]/u_sq[0] +Rs[1]/u_sq[1] + ...)

    let dimension = 4;
    let mut transcript = Transcript::new(username.clone().leak().as_bytes());
    let bp_gens = BulletproofGens::new(dimension, 1);
    let G: Vec<RistrettoPoint> = bp_gens.share(0).G(dimension).cloned().collect();
    let mut rng = rand::thread_rng();
    let lg2_n = 2; //log2(dimension)
    let G_factors: Vec<Scalar> = iter::repeat(Scalar::ONE).take(dimension).collect();

    let L_vec: Vec<CompressedRistretto> = (0..lg2_n).map(|_| RistrettoPoint::random(&mut rng).compress()).collect();
    let R_vec: Vec<CompressedRistretto> = (0..lg2_n).map(|_| RistrettoPoint::random(&mut rng).compress()).collect();
    

    let Ls = L_vec.iter().map(|p| p.decompress().ok_or(ProofError::VerificationError)).collect::<Result<Vec<_>, _>>()?;
    let Rs = R_vec.iter().map(|p| p.decompress().ok_or(ProofError::VerificationError)).collect::<Result<Vec<_>, _>>()?;

    let (u_sq, u_inv_sq, s) = verification_scalars(&L_vec, &R_vec, dimension, &mut transcript)?;
    let a = Scalar::random(&mut rng);
    let b = Scalar::from(0u32);
    let g_times_a_times_s = G_factors.into_iter().zip(s.iter()).map(|(g_i, s_i)| (a * s_i) * g_i.borrow()).take(G.len());
    let neg_u_sq = u_sq.iter().map(|ui| -ui);
    let neg_u_inv_sq = u_inv_sq.iter().map(|ui| -ui);

    let expect_P = RistrettoPoint::vartime_multiscalar_mul(
        neg_u_inv_sq.chain(neg_u_sq).chain(g_times_a_times_s),
            Rs.iter().chain(Ls.iter()).chain(G.iter())
    );
    let result = format_proof(&expect_P, &InnerProductProofForge{a:a,b:b,L_vec:L_vec,R_vec:R_vec});
    Ok(STANDARD.encode(result))

}

use std::env;

fn main(){
    // argv[1]
    let username = &env::args().collect::<Vec<String>>()[1];

    let forged_proof = forge_proof(username);
    match forged_proof{
        Ok(v) => println!("{}", v),
        Err(e) => println!("ERROR")
    }
    
}